<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十六)--JSP指令]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E5%85%AD-JSP%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十五)--JSP基础语法]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%94-JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 任何语言都有自己的语法，JAVA中有，JSP虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在JSP中，所有的JAVA语句都可以使用。 一、JSP模版元素 JSP页面中的HTML内容称之为JSP模版元素。 JSP模版元素定义了网页的基本骨架，即定义了页面的结构和外观。 二、JSP表达式 JSP脚本表达式（expression）用于将程序数据输出到客户端​ 语法：&lt;%= 变量或表达式 %&gt;​ 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。语法： &lt;% 多行java代码 %&gt; 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法。 范例：在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项： JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 ​ 举例： 123456789&lt;% int x = 10; out.println(x);%&gt;&lt;p&gt;这是JSP页面文本&lt;/p&gt;&lt;% int y = 20; out.println(y);%&gt; 多个脚本片断中的代码可以相互访问，犹如将所有的代码放在一对&lt;%%&gt;之中的情况。如：out.println(x); 单个脚本片断中的Java语句可以是不完整的，但是，多个脚本片断组合后的结果必须是完整的Java语句，例如： 12345678&lt;% for (int i=1; i&lt;5; i++) &#123;%&gt; &lt;H1&gt;http://localhost:8080/JavaWeb_Jsp_Study_20140603/&lt;/H1&gt;&lt;% &#125;%&gt; 四、JSP声明 JSP页面中编写的所有代码，默认会翻译到servlet的service方法中， 而Jsp声明中的java代码被翻译到_jspService方法的外面。语法： &lt;%！ java代码 %&gt; 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。 JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。 JSP声明案例： 1234567891011121314151617&lt;%!static &#123; System.out.println("loading Servlet!"); &#125;private int globalVar = 0;public void jspInit()&#123; System.out.println("initializing jsp!");&#125;%&gt;&lt;%!public void jspDestroy()&#123; System.out.println("destroying jsp!");&#125;%&gt; 五、JSP注释在JSP中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - **注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/***……*/** **JSP自己的注释：&lt;%- - 注释内容- -%&gt;** 这三种注释的区别 1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容的，这就是这三种注释的区别。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十四)--JSP原理]]></title>
    <url>%2F2017%2F07%2F04%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B-JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是JSP？ JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。 二、JSP原理2.1、Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet，服务器在执行jsp的时候，首先把jsp翻译成一个Servlet，所以我们访问jsp时，其实不是在访问jsp，而是在访问jsp翻译过后的那个Servlet，例如下面的代码： 3.jsp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午11:20 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;html&gt;&lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% out.print("Hello Jsp"); %&gt;&lt;/body&gt;&lt;/html&gt; 当我们通过浏览器访问3.jsp时，服务器首先将index.jsp翻译成一个_3_jsp.class，在Tomcat服务器的work\Catalina\localhost\项目名\org\apache\jsp目录下可以看到_3_jsp.class的源代码文件index_jsp.java，index_jsp.java的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/8.0.41 * Generated at: 2017-07-04 03:25:11 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class _3_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages; private static final java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes; static &#123; _jspx_imports_packages = new java.util.HashSet&lt;&gt;(); _jspx_imports_packages.add("javax.servlet"); _jspx_imports_packages.add("javax.servlet.http"); _jspx_imports_packages.add("javax.servlet.jsp"); _jspx_imports_classes = null; &#125; private volatile javax.el.ExpressionFactory _el_expressionfactory; private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123; return _jspx_dependants; &#125; public java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123; return _jspx_imports_packages; &#125; public java.util.Set&lt;java.lang.String&gt; getClassImports() &#123; return _jspx_imports_classes; &#125; public javax.el.ExpressionFactory _jsp_getExpressionFactory() &#123; if (_el_expressionfactory == null) &#123; synchronized (this) &#123; if (_el_expressionfactory == null) &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); &#125; &#125; &#125; return _el_expressionfactory; &#125; public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() &#123; if (_jsp_instancemanager == null) &#123; synchronized (this) &#123; if (_jsp_instancemanager == null) &#123; _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; &#125; &#125; return _jsp_instancemanager; &#125; public void _jspInit() &#123; &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123;final java.lang.String _jspx_method = request.getMethod();if (!"GET".equals(_jspx_method) &amp;&amp; !"POST".equals(_jspx_method) &amp;&amp; !"HEAD".equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");return;&#125; final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType("text/html;charset=UTF-8"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write('\n'); out.write('\n'); String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; out.write("\n"); out.write("&lt;html&gt;\n"); out.write("&lt;head&gt;\n"); out.write(" &lt;base href=\""); out.print(basePath); out.write("\"&gt;\n"); out.write(" &lt;title&gt;Title&lt;/title&gt;\n"); out.write("&lt;/head&gt;\n"); out.write("&lt;body&gt;\n"); out.write(" "); out.print("Hello Jsp"); out.write("\n"); out.write("&lt;/body&gt;\n"); out.write("&lt;/html&gt;\n"); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; if (response.isCommitted()) &#123; out.flush(); &#125; else &#123; out.clearBuffer(); &#125; &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 2.3、Jsp页面中的java代码服务器是如何执行的？ 在jsp中编写的java代码会被翻译到_jspService方法中去，当执行_jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 2.4、Web服务器在调用jsp时，会给jsp提供一些什么java对象？ 查看_jspService方法可以看到，Web服务器在调用jsp时，会给Jsp提供如下的8个java对象 12345678PageContext pageContext;HttpSession session;ServletContext application;ServletConfig config;JspWriter out;Object page = this;HttpServletRequest request, HttpServletResponse response 其中page对象，request和response已经完成了实例化，而其它5个没有实例化的对象通过下面的方式实例化 12345pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); 8个java对象可以直接使用 12345678910111213&lt;% session.setAttribute("name", "session对象");//使用session对象，设置session对象属性 out.print(session.getAttribute("name") + "&lt;br /&gt;");//获取session对象的属性 pageContext.setAttribute("name", "pageContext对象");//使用pageContext对象 out.print(pageContext.getAttribute("name") + "&lt;br /&gt;");//获取pageContext对象 application.setAttribute("name", "application对象");//使用application对象,设置application对象的属性 out.print(application.getAttribute("name") + "&lt;br/&gt;");//获取application对象的属性 out.print("Hello Jsp" + "&lt;br/&gt;");//使用out对象 out.print("服务器调用index.jsp页面时翻译成的类的名字是：" + page.getClass() + "&lt;br/&gt;");//使用page对象 out.print("处理请求的Servlet的名字是：" + config.getServletName().toString() + "&lt;br/&gt;");//使用config对象 out.print(response.getContentType() + "&lt;br/&gt;");//使用response对象 out.print(request.getContextPath() + "&lt;br/&gt;");//使用request对象%&gt; 运行结果如下： 2.5、Jsp最佳实践 Jsp最佳实践就是jsp技术在开发中该怎么去用。 不管是JSP还是Servlet，虽然都可以用于开发动态web资源。但由于这2门技术各自的特点，在长期的软件实践中，人们逐渐把servlet作为web应用中的控制器组件来使用，而把JSP技术作为数据显示模板来使用。其原因为，程序的数据通常要美化后再输出：让jsp既用java代码产生动态数据，又做美化会导致页面难以维护。让servlet既产生数据，又在里面嵌套html代码美化数据，同样也会导致程序可读性差，难以维护。因此最好的办法就是根据这两门技术的特点，让它们各自负责各的，servlet只负责响应请求产生数据，并把数据通过转发技术带给jsp，数据的显示jsp来做。 2.6、Tomcat服务器的执行流程 第一次执行： 客户端通过电脑连接服务器，因为是请求是动态的，所以所有的请求交给WEB容器来处理 在容器中找到需要执行的*.jsp文件 之后.jsp文件通过转换变为.java文件 .java文件经过编译后，形成.class文件 最终服务器要执行形成的*.class文件 第二次执行： 因为已经存在了*.class文件，所以不在需要转换和编译的过程 修改后执行： ​ 1.源文件已经被修改过了，所以需要重新转换，重新编译。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十三)--使用session防止表单重复提交]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89-%E4%BD%BF%E7%94%A8session%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[[TOC] 在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。 一、表单重复提交的常见应用场景有如下的form.jsp页面 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台servlet 12345678910111213141516171819202122232425262728package org.wuqinghua.java.ch06;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); String username = req.getParameter("username"); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("向数据库中添加数据："+username); &#125;&#125; 如果没有进行form表单重复提交处理，那么在网络延迟的情况下下面的操作将会导致form表单重复提交多次 1.1、场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 演示动画如下所示： 1.2、场景二：表单提交后用户点击【刷新】按钮导致表单重复提交演示动画如下所示： 点击浏览器的刷新按钮，就是把浏览器上次做的事情再做一次，因为这样也会导致表单重复提交。 1.3、场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交演示动画如下所示： 二、利用JavaScript防止表单重复提交 既然存在上述所说的表单重复提交问题，那么我们就要想办法解决，比较常用的方法是采用JavaScript来防止表单重复提交，具体做法如下： 修改form.jsp页面，添加如下的JavaScript代码来防止表单重复提交 12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt; &lt;script&gt; var isCommitted = false;//表单 function doSubmit()&#123; if (!isCommitted)&#123; isCommitted=true; return true; &#125;else&#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post" onsubmit="return doSubmit()"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 我们看看使用了JavaScript来防止表单提交重复是否可以成功，运行效果如下： 可以看到，针对”在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交“这个应用场景，使用JavaScript是可以解决这个问题的，解决的做法就是“用JavaScript控制Form表单只能提交一次“。 除了用这种方式之外，经常见的另一种方式就是表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮，代码如下： 12345678function dosubmit()&#123; //获取表单提交按钮 var btnSubmit = document.getElementById("submit"); //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮 btnSubmit.disabled= "disabled"; //返回true让表单可以正常提交 return true;&#125; 运行效果如下： 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题。 三、利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 具体的做法：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。 在下列情况下，服务器程序将拒绝处理用户提交的表单请求： 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。 当前用户的Session中不存在Token(令牌)。 用户提交的表单数据中没有Token(令牌)。 看具体的范例： 1.创建FormServlet，用于生成Token(令牌)和跳转到form.jsp页面 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/4 Time: 上午8:33 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/repeatSubmitServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;input type="hidden" name="token" value="$&#123;token&#125;"/&gt; &lt;input type="submit" value="提交" id="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * Created by wuqinghua on 17/7/4. */@WebServlet(urlPatterns = "/repeatSubmitServlet")public class RepeatSubmitServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String token = TokenProccessor.getInstance().makeToken(); req.getSession().setAttribute("token", token); req.getRequestDispatcher("form.jsp").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); if (!isRepeat(req)) &#123; String username = req.getParameter("username"); System.out.println("向数据库中添加数据：" + username); &#125; &#125; private boolean isRepeat(HttpServletRequest req) &#123; String token = req.getParameter("token"); if (token == null || "".equals(token)) &#123; return true; &#125; String sessionToken = (String) req.getSession().getAttribute("token"); if (sessionToken == null || "".equals(sessionToken)) &#123; return true; &#125; if (!token.equals(sessionToken)) &#123; return true; &#125; req.getSession().removeAttribute("token"); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package org.wuqinghua.java.ch06;import org.wuqinghua.java.repeat.TokenProccessor;import sun.misc.BASE64Encoder;import sun.plugin2.message.Message;import javax.xml.crypto.dsig.DigestMethod;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;import java.util.Random;/** * Created by wuqinghua on 17/7/4. */public class TokenProcessor &#123; /** * 单例设计模式 * 1.把类的构造方法设计为私有的 * 2.自己创建一个类的对象 * 3.对外提供一个公共的方法，返回类的对象 */ private static TokenProccessor instance = new TokenProccessor(); private TokenProcessor()&#123;&#125; public static TokenProccessor getInstance()&#123; return instance; &#125; public String makeToken()&#123; String token = (System.currentTimeMillis()+new Random().nextInt(999999999))+""; try &#123; MessageDigest md5 = MessageDigest.getInstance("md5"); byte[] digest = md5.digest(token.getBytes()); BASE64Encoder base64Encoder = new BASE64Encoder(); return base64Encoder.encode(digest); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 首先访问FormServlet，在FormServlet中生成Token之后再重定向到form.jsp页面，这次是在服务器端处理表单重复提交的，运行效果如下： 从运行效果中可以看到，通过这种方式处理表单重复提交，可以解决上述的场景二和场景三中出现的表单重复提交问题。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十二)--Session]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C-Session%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Session简单介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 二、Session和Cookie的主要区别 Cookie是把用户的数据写给用户的浏览器。 Session技术把用户的数据写到用户独占的session中。 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 三、session实现原理3.1、服务器是如何实现一个session为一个用户浏览器服务的？ 服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。可以用如下的代码证明： 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/sessionDemo01")public class SessionDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); HttpSession session = req.getSession();//获取session //将数据存储进去 session.setAttribute("data","孤傲苍狼"); //获取session的id String sessionId = session.getId(); //判断session是否为新的 if(session.isNew())&#123; resp.getWriter().print("session创建成功！sessionId为:"+sessionId); &#125;else&#123; resp.getWriter().print("服务器已经存在该session了,sessionId为:"+sessionId); &#125; &#125;&#125; 第一次访问时，服务器会创建一个新的sesion，并且把session的Id以cookie的形式发送给客户端浏览器，如下图所示： 点击刷新按钮，再次请求服务器，此时就可以看到浏览器再请求服务器时，会把存储到cookie中的session的Id一起传递到服务器端了，如下图所示： 我猜想request.getSession()方法内部新创建了Session之后一定是做了如下的处理 1234567//获取session的IdString sessionId = session.getId();//将session的Id存储到名字为JSESSIONID的cookie中Cookie cookie = new Cookie("JSESSIONID", sessionId);//设置cookie的有效路径cookie.setPath(request.getContextPath());response.addCookie(cookie); 四、浏览器禁用Cookie后的session处理4.1、IE8禁用cookie1 工具-&gt;internet选项-&gt;隐私-&gt;设置-&gt;将滑轴拉到最顶上（阻止所有cookies） 4.2、解决方案：URL重写 response.encodeRedirectURL(java.lang.String url) 用于对sendRedirect方法后的url地址进行重写。 response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写 4.3、范例：禁用Cookie后servlet共享Session中的数据IndexServlet 12345678910111213141516171819202122232425262728293031323334353637package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/index")public class IndexServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); //创建session req.getSession(); out.print("本网站有如下图书:&lt;br /&gt;"); Map&lt;String,Book&gt; books = DB.getAll(); for (Map.Entry&lt;String,Book&gt; book: books.entrySet()) &#123; Book b = book.getValue(); String url = req.getContextPath()+"/buyServlet?id="+b.getId(); url = resp.encodeURL(url);//对于表单的action和超链接使用此方法重写 out.print(b.getName()+"&lt;a href='"+url+"'&gt;购买&lt;/a&gt;&lt;br /&gt;"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829package org.wuqinghua.java.ch03;import java.util.HashMap;import java.util.Map;import java.util.StringJoiner;/** * Created by wuqinghua on 17/6/30. * 模拟数据库 */public class DB &#123; private static Map&lt;String, Book&gt; map = new HashMap&lt;&gt;(); static &#123; map.put("1", new Book("1", "javaweb开发")); map.put("2", new Book("2", "spring开发")); map.put("3", new Book("3", "hibernate开发")); map.put("4", new Book("4", "struts开发")); map.put("5", new Book("5", "ajax开发")); &#125; public static Map&lt;String,Book&gt; getAll()&#123; return map; &#125; public static Book get(String id)&#123; return map.get(id); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch03;/** * Created by wuqinghua on 17/6/30. */public class Book &#123; private String id; private String name; public Book() &#123; &#125; public Book(String id, String name) &#123; this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/buyServlet")public class BuyServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String id = req.getParameter("id"); Book book = DB.get(id);//得到想要购买的书 HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null)&#123; books = new ArrayList&lt;&gt;(); session.setAttribute("books",books); &#125; books.add(book); String url = resp.encodeRedirectURL(req.getContextPath()+"/listCartServlet"); System.out.println(url); resp.sendRedirect(url); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package org.wuqinghua.java.ch03;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;import java.util.List;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/listCartServlet")public class ListCartServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); HttpSession session = req.getSession(); List&lt;Book&gt; books = (List&lt;Book&gt;) session.getAttribute("books"); if(books==null || books.size()==0)&#123; out.print("对不起，您没有购买任何产品。"); return; &#125; //显示用户的购买纪录 out.write("您买过如下产品:&lt;br /&gt;"); for (Book book: books) &#123; out.write(book.getName()+"&lt;br /&gt;"); &#125; &#125;&#125; 在禁用了cookie的IE8下的运行效果如下： 通过查看IndexServlet生成的html代码可以看到，每一个超链接后面都带上了session的Id，如下所示 12345本网站有如下书：&lt;br/&gt;javaweb开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=1'&gt;购买&lt;/a&gt;&lt;br/&gt;spring开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=2'&gt;购买&lt;/a&gt;&lt;br/&gt;hibernate开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=3'&gt;购买&lt;/a&gt;&lt;br/&gt;struts开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=4'&gt;购买&lt;/a&gt;&lt;br/&gt;ajax开发 &lt;a href='/JavaWeb_Session_Study_20140720/servlet/BuyServlet;jsessionid=96BDFB9D87A08D5AB1EAA2537CDE2DB2?id=5'&gt;购买&lt;/a&gt;&lt;br/&gt; 所以，当浏览器禁用了cookie后，就可以用URL重写这种解决方案解决Session数据共享问题。而且response. encodeRedirectURL(java.lang.String url) 和response. encodeURL(java.lang.String url)是两个非常智能的方法，当检测到浏览器没有禁用cookie时，那么就不进行URL重写了。我们在没有禁用cookie的火狐浏览器下访问，效果如下： 从演示动画中可以看到，浏览器第一次访问时，服务器创建Session，然后将Session的Id以Cookie的形式发送回给浏览器，response. encodeURL(java.lang.String url)方法也将URL进行了重写，当点击刷新按钮第二次访问，由于火狐浏览器没有禁用cookie，所以第二次访问时带上了cookie，此时服务器就可以知道当前的客户端浏览器并没有禁用cookie，那么就通知response. encodeURL(java.lang.String url)方法不用将URL进行重写了。 五、session对象的创建和销毁时机5.1、session对象的创建时机 在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 范例：创建session 12345678910//使用request对象的getSession()获取session，如果session不存在则创建一个HttpSession session = request.getSession();//获取session的IdString sessionId = session.getId();//判断session是不是新创建的if (session.isNew()) &#123; response.getWriter().print("session创建成功，session的id是："+sessionId);&#125;else &#123; response.getWriter().print("服务器已经存在session，session的id是："+sessionId);&#125; 5.2、session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间，例如： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 设置Session的有效时间:以分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。 123 HttpSession session = request.getSession();//手工调用session.invalidate方法，摧毁session session.invalidate();]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十一)--使用Cookie进行会话管理]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80-%E4%BD%BF%E7%94%A8Cookie%E8%BF%9B%E8%A1%8C%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术3.1、Cookie Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 3.2、Session Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 四、Java提供的操作Cookie的API Java中的javax.servlet.http.Cookie类用于创建一个Cookie Cookie类的主要方法 No. 方法 类型 描述 1 Cookie(String name, String value) 构造方法 实例化Cookie对象，传入cooke名称和cookie的值 2 public String getName() 普通方法 取得Cookie的名字 3 public String getValue() 普通方法 取得Cookie的值 4 public void setValue(String newValue) 普通方法 设置Cookie的值 5 public void setMaxAge(int expiry) 普通方法 设置Cookie的最大保存时间，即cookie的有效期，当服务器给浏览器回送一个cookie时，如果在服务器端没有调用setMaxAge方法设置cookie的有效期，那么cookie的有效期只在一次会话过程中有效，用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一次会话，当用户关闭浏览器，会话就结束了，此时cookie就会失效，如果在服务器端使用setMaxAge方法设置了cookie的有效期，比如设置了30分钟，那么当服务器把cookie发送给浏览器时，此时cookie就会在客户端的硬盘上存储30分钟，在30分钟内，即使浏览器关了，cookie依然存在，在30分钟内，打开浏览器访问服务器时，浏览器都会把cookie一起带上，这样就可以在服务器端获取到客户端浏览器传递过来的cookie里面的信息了，这就是cookie设置maxAge和不设置maxAge的区别，不设置maxAge，那么cookie就只在一次会话中有效，一旦用户关闭了浏览器，那么cookie就没有了，那么浏览器是怎么做到这一点的呢，我们启动一个浏览器，就相当于启动一个应用程序，而服务器回送的cookie首先是存在浏览器的缓存中的，当浏览器关闭时，浏览器的缓存自然就没有了，所以存储在缓存中的cookie自然就被清掉了，而如果设置了cookie的有效期，那么浏览器在关闭时，就会把缓存中的cookie写到硬盘上存储起来，这样cookie就能够一直存在了。 6 public int getMaxAge() 普通方法 获取Cookies的有效期 7 public void setPath(String uri) 普通方法 设置cookie的有效路径，比如把cookie的有效路径设置为”/xdp”，那么浏览器访问”xdp”目录下的web资源时，都会带上cookie，再比如把cookie的有效路径设置为”/xdp/gacl”，那么浏览器只有在访问”xdp”目录下的”gacl”这个目录里面的web资源时才会带上cookie一起访问，而当访问”xdp”目录下的web资源时，浏览器是不带cookie的 8 public String getPath() 普通方法 获取cookie的有效路径 9 public void setDomain(String pattern) 普通方法 设置cookie的有效域 10 public String getDomain() 普通方法 获取cookie的有效域 response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。 五、Cookie使用范例5.1、使用cookie记录用户上一次访问的时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/cookieDemo01"&#125;)public class CookieDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置服务器以UTF－8编码进行输出 resp.setCharacterEncoding("utf-8"); //设置浏览器以UTF－8进行接受，解决乱码问题 resp.setContentType("text/html;charset=UTF-8"); PrintWriter writer = resp.getWriter(); //获取浏览器访问服务器时传递的cookie Cookie[] cookies = req.getCookies(); //如果是第一次访问那么cookies为null if (cookies!=null)&#123; writer.print("您上次访问的时间为:"); for (Cookie cookie: cookies) &#123; if(cookie.getName().equals("lastAccessTime"))&#123; long lastAccessTime = Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); writer.write(date.toLocaleString()); &#125; &#125; &#125;else&#123; writer.write("您是第一次访问本站."); &#125; //用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie添加到resp对象中 resp.addCookie(cookie); &#125;&#125; 第一次访问时这个Servlet时，效果如下所示： 点击浏览器的刷新按钮，进行第二次访问，此时就服务器就可以通过cookie获取浏览器上一次访问的时间了，效果如下： 在上面的例子中，在程序代码中并没有使用setMaxAge方法设置cookie的有效期，所以当关闭浏览器之后，cookie就失效了，要想在关闭了浏览器之后，cookie依然有效，那么在创建cookie时，就要为cookie设置一个有效期。如下所示： 123456//用户访问之后重新设置用户的访问时间,存储到cookie中，然后在发送给浏览器 Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //设置Cookie有效期为一天 cookie.setMaxAge(24*60*60); //将cookie添加到resp对象中 resp.addCookie(cookie); 用户第一次访问时，服务器发送给浏览器的cookie就存储到了硬盘上，如下所示： 这样即使关闭了浏览器，下次再访问时，也依然可以通过cookie获取用户上一次访问的时间。 六、Cookie注意细节 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 6.1、删除Cookie注意：删除cookie时，path必须一致，否则不会删除 12345678910111213141516171819202122232425package org.wuqinghua.java.ch02;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/cookieDemo02")public class CookieDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建一个名字为lastAccessTime的cookie Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+""); //将cookie的有效期设置为0，命令浏览器删除该cookie cookie.setMaxAge(0); resp.addCookie(cookie); &#125;&#125; 6.2、cookie中存取中文 要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码，例如： 1Cookie cookie = new Cookie("userName", URLEncoder.encode("孤傲苍狼", "UTF-8")); response.addCookie(cookie); 在获取cookie中的中文数据时，再使用URLDecoder类里面的decode(String s, String enc)进行解码，例如： 1URLDecoder.decode(cookies[i].getValue(), "UTF-8")]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(十)--HttpServletRequest]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%81-HttpServletRequest%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletRequest介绍 HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。 二、Request常用方法2.1、获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 范例：通过request对象获取客户端请求信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo01")public class RequestDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 获取客户端信息 */ String requestUrl = req.getRequestURL().toString();//获取请求的url地址 String requestURI = req.getRequestURI();//获取请求的资源 String queryString = req.getQueryString();//获取请求参数中附带的参数 String remoteAddr = req.getRemoteAddr();//获取来访的ip String remoteHost = req.getRemoteHost(); int remotePort = req.getRemotePort();//获取来访的端口 String remoteUser = req.getRemoteUser(); String method = req.getMethod();//得到请求url使用的方法 String pathInfo = req.getPathInfo(); String localAddr = req.getLocalAddr();//获取服务器的ip地址 String localName = req.getLocalName();//获取服务器的主机名称 resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); out.print("获取到的客户机信息如下:"); out.print("&lt;hr /&gt;"); out.print("请求的url：" + requestUrl); out.print("&lt;br /&gt;"); out.print("请求的资源:" + requestURI); out.print("&lt;br /&gt;"); out.print("附带的参数:" + queryString); out.print("&lt;br /&gt;"); out.print("来访者的ip地址:" + remoteAddr); out.print("&lt;br /&gt;"); out.print("来访者的主机名称:" + remoteHost); out.print("&lt;br /&gt;"); out.print("来访者的端口:" + remotePort); out.print("&lt;br /&gt;"); out.print("remoteUser:" + remoteUser); out.print("&lt;br /&gt;"); out.print("请求方法:" + method); out.print("&lt;br /&gt;"); out.print("pathInfo:" + pathInfo); out.print("&lt;br /&gt;"); out.print("服务器的ip:" + localAddr); out.print("&lt;br /&gt;"); out.print("服务器的主机:" + localName); &#125;&#125; 运行结果： 2.2、获得客户机请求头 getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法 范例：通过request对象获取客户端请求头信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo02")public class ResquestDemo02 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("utf-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); Enumeration&lt;String&gt; headerNames = req.getHeaderNames();//获取所有的头部 out.print("获取客户端请求头部如下:"); out.print("&lt;hr /&gt;"); while (headerNames.hasMoreElements())&#123; String headName = headerNames.nextElement(); String headerValue = req.getHeader(headName);//根据头部名称获取头部值 out.print(headName+":"+headerValue); out.print("&lt;br /&gt;"); &#125; out.write("&lt;br/&gt;"); out.write("获取到的客户端Accept-Encoding请求头的值："); out.write("&lt;hr/&gt;"); String value = req.getHeader("Accept-Encoding");//获取Accept-Encoding请求头对应的值 out.write(value); Enumeration&lt;String&gt; e = req.getHeaders("Accept-Encoding"); while (e.hasMoreElements()) &#123; String string = e.nextElement(); System.out.println(string); &#125; &#125;&#125; 运行结果如下： 2.3、获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 比如现在有如下的form表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Html的Form表单元素&lt;/title&gt;&lt;/head&gt;&lt;fieldset style="width:500px;"&gt; &lt;legend&gt;Html的Form表单元素&lt;/legend&gt; &lt;!--form表单的action属性规定当提交表单时，向何处发送表单数据，method属性指明表单的提交方式，分为get和post，默认为get--&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo03" method="post"&gt; &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt; 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt;&lt;br&gt; &lt;!--输入文本框，通过value指定其显示的默认值--&gt; 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt;&lt;br&gt; &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt; 密&amp;nbsp;&amp;nbsp;码(密码框)： &lt;!--&amp;nbsp;表示的是一个空格--&gt; &lt;input type="password" name="userpass" value="请输入密码"&gt;&lt;br&gt; &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt; 性&amp;nbsp;&amp;nbsp;别(单选框)： &lt;input type="radio" name="sex" value="男" checked&gt;男 &lt;input type="radio" name="sex" value="女"&gt;女&lt;br&gt; &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt; 部&amp;nbsp;&amp;nbsp;门(下拉框)： &lt;select name="dept"&gt; &lt;option value="技术部"&gt;技术部&lt;/option&gt; &lt;option value="销售部" SELECTED&gt;销售部&lt;/option&gt; &lt;option value="财务部"&gt;财务部&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt; 兴&amp;nbsp;&amp;nbsp;趣(复选框)： &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌 &lt;input type="checkbox" name="inst" value="游泳"&gt;游泳 &lt;input type="checkbox" name="inst" value="跳舞"&gt;跳舞 &lt;input type="checkbox" name="inst" value="编程" checked&gt;编程 &lt;input type="checkbox" name="inst" value="上网"&gt;上网 &lt;br&gt; &lt;!--大文本输入框，宽度为34列，高度为5行--&gt; 说&amp;nbsp;&amp;nbsp;明(文本域)： &lt;textarea name="note" cols="34" rows="5"&gt; &lt;/textarea&gt; &lt;br&gt; &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt; &lt;input type="hidden" name="hiddenField" value="hiddenvalue"/&gt; &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt; &lt;input type="submit" value="提交(提交按钮)"&gt; &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt; &lt;input type="reset" value="重置(重置按钮)"&gt;&lt;/form&gt;&lt;!--表单结束--&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;!--完结标记--&gt;&lt;/html&gt;&lt;!--完结标记--&gt; 在Form表单中填写数据，然后提交到RequestDemo03这个Servlet进行处理，填写的表单数据如下： 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package gacl.request.study;import java.io.IOException;import java.text.MessageFormat;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //客户端是以UTF-8编码提交表单数据的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;input type="text" name="userid" value="NO." size="2" maxlength="2"&gt; */ String userid = request.getParameter("userid");//获取填写的编号，userid是文本框的名字，&lt;input type="text" name="userid"&gt; /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; */ String username = request.getParameter("username");//获取填写的用户名 /** * 密&amp;nbsp;&amp;nbsp;码(密码框)：&lt;input type="password" name="userpass" value="请输入密码"&gt; */ String userpass = request.getParameter("userpass");//获取填写的密码 String sex = request.getParameter("sex");//获取选中的性别 String dept = request.getParameter("dept");//获取选中的部门 //获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用getParameterValues方法来获取 String[] insts = request.getParameterValues("inst"); String note = request.getParameter("note");//获取填写的说明信息 String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 String instStr=""; /** * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！ */ for (int i = 0; insts!=null &amp;&amp; i &lt; insts.length; i++) &#123; if (i == insts.length-1) &#123; instStr+=insts[i]; &#125;else &#123; instStr+=insts[i]+","; &#125; &#125; String htmlStr = "&lt;table&gt;" + "&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的部门：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;" + "&lt;/table&gt;"; htmlStr = MessageFormat.format(htmlStr, userid,username,userpass,sex,dept,instStr,note,hiddenField); response.setCharacterEncoding("UTF-8");//设置服务器端以UTF-8编码输出数据到客户端 response.setContentType("text/html;charset=UTF-8");//设置客户端浏览器以UTF-8编码解析数据 response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 在服务器端使用getParameterNames方法接收表单参数，代码如下： 123456Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名 while (paramNames.hasMoreElements()) &#123; String name = paramNames.nextElement();//得到参数名 String value = request.getParameter(name);//通过参数名获取对应的值 System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", name,value)); &#125; 运行结果如下： 在服务器端使用getParameterMap方法接收表单参数，代码如下： 123456789101112131415//request对象封装的参数是以Map的形式存储的 Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123; String paramName = entry.getKey(); String paramValue = ""; String[] paramValueArr = entry.getValue(); for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123; if (i == paramValueArr.length-1) &#123; paramValue+=paramValueArr[i]; &#125;else &#123; paramValue+=paramValueArr[i]+","; &#125; &#125; System.out.println(MessageFormat.format("&#123;0&#125;=&#123;1&#125;", paramName,paramValue)); &#125; 运行结果如下： 三、request接收表单提交中文参数乱码问题3.1、以POST方式提交表单中文参数的乱码问题例如有如下的form表单页面： 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: wuqinghua Date: 17/7/3 Time: 下午9:13 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request接受正文参数乱码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="&lt;%=request.getContextPath()%&gt;/requestDemo04" method="post"&gt; 用户名： &lt;input type="text" name="userName"/&gt; &lt;input type="submit" value="post方式提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码如下: 1234567891011121314151617181920package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 运行结果为： 3.2、post方式提交中文数据乱码产生的原因和解决办法 可以看到，之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下： 1234567891011121314151617181920212223242526package org.wuqinghua.java.ch05;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/requestDemo04")public class RequestDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 客户端是以utf-8的编码提交到后台的，所以需要设置服务器端以utf－8的编码进行接收，否则对于中文数据就会产生乱码 */ req.setCharacterEncoding("UTF-8"); String userName = req.getParameter("userName"); System.out.println("userName:"+userName); &#125;&#125; 3.3、以GET方式提交表单中文参数的乱码问题12345678910public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * * 对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的，默认的还是使用ISO8859-1这个字符编码来接收数据 */ String name = request.getParameter("name");//接收数据 name =new String(name.getBytes("ISO8859-1"), "UTF-8") ;//获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题 System.out.println("name："+name); &#125; 3.6、提交中文数据乱码问题总结 1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”)) 2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下： 1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????” String data = request.getParameter(“paramName”); 2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组 byte[] source = data.getBytes(“ISO8859-1”); 3).通过字节数组以指定的编码构建字符串，解决乱码 data = new String(source, “UTF-8”); 通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”) 四、Request对象实现请求转发4.1、请求转发的基本概念 请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。 请求转发的应用场景：MVC设计模式 在Servlet中实现请求转发的两种方式： 1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 121 RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);2 reqDispatcher.forward(request, response); 2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。 例如：将请求转发的test.jsp页面 11 request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作 setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(“data”, data); getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(“data”) removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(“data”) getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration attrNames = request.getAttributeNames(); 4.2、请求重定向和请求转发的区别 一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。 一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(九)--通过Servlet生成验证码]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B9%9D-%E9%80%9A%E8%BF%87Servlet%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[TOC] 一、BufferedImage类介绍生成验证码图片主要用到了一个BufferedImage类，如下： 创建一个DrawImage Servlet，用来生成验证码图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/3. */@WebServlet(urlPatterns = "/drawImage")public class DrawImage extends HttpServlet &#123; public static final int WIDTH = 120;//生成的图片的宽度 public static final int HEIGHT = 30;//生成的图片的高度 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String createTypeFlag = req.getParameter("createTypeFlag"); //1.在内存中创建一个图片 BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); //2.获取到画笔 Graphics2D g = (Graphics2D) image.getGraphics(); //3.设置图片的背景颜色 setBackground(g, Color.WHITE); //4.设置边框 setBorder(g, Color.BLUE); //5.在图片上设置干扰线 drawRandomLine(g, Color.GREEN, 5); //6.在图片上生成随机验证码 String code = drawRandomCode(g, Color.RED, ImageType.getImageType(createTypeFlag)); //7.将验证码存入到session req.getSession().setAttribute("code", code); //8.设置响应头 resp.setHeader("content-type", "image/jpeg"); //9.不要缓存 resp.setDateHeader("expries", -1); resp.setHeader("Cache-Control", "no-cache"); resp.setHeader("Pragma", "no-cache"); //10.将图片写入浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; /** * 生成随机验证码 * * @param g * @param color * @param imageType * @return */ private String drawRandomCode(Graphics2D g, Color color, ImageType imageType) &#123; g.setColor(color); //设置字体 g.setFont(new Font("宋体", Font.BOLD, 20)); //常用的中国汉字 String baseChineseChar = "\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6"; //数字和字母的组合 String baseNumLetter = "0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ"; //纯数字 String baseNum = "0123456789"; //纯字母 String baseLetter = "ABCDEFGHJKLMNOPQRSTUVWXYZ"; switch (imageType) &#123; case CH://汉字 return createRandomChar(g, baseChineseChar); case NL://数字和字母 return createRandomChar(g, baseNumLetter); case L: return createRandomChar(g, baseLetter); default: return createRandomChar(g, baseNum); &#125; &#125; /** * 根据基础字符生成随机字符串 * * @param g * @param baseChar * @return */ private String createRandomChar(Graphics2D g, String baseChar) &#123; StringBuffer buffer = new StringBuffer(); int x = 5; String ch = ""; //控制字数 for (int i = 0; i &lt; 4; i++) &#123; //设置字体的旋转角度 int degree = new Random().nextInt() % 30; ch = baseChar.charAt(new Random().nextInt(baseChar.length())) + ""; buffer.append(ch); //正向角度 g.rotate(degree * Math.PI / 180, x, 20); g.drawString(ch, x, 20); //反向角度 g.rotate(-degree * Math.PI / 180, x, 20); x += 30; &#125; return buffer.toString(); &#125; /** * 设置干扰线 * * @param g */ private void drawRandomLine(Graphics2D g, Color color, int lineCount) &#123; g.setColor(color); for (int i = 0; i &lt; lineCount; i++) &#123; int x1 = new Random().nextInt(WIDTH); int y1 = new Random().nextInt(HEIGHT); int x2 = new Random().nextInt(WIDTH); int y2 = new Random().nextInt(HEIGHT); g.drawLine(x1, y1, x2, y2); &#125; &#125; /** * 设置边框 * * @param g * @param color */ private void setBorder(Graphics2D g, Color color) &#123; g.setColor(color); g.drawRect(1, 1, WIDTH - 2, HEIGHT - 2); &#125; /** * 设置背景颜色 * * @param g */ private void setBackground(Graphics2D g, Color color) &#123; g.setColor(color); g.fillRect(0, 0, WIDTH, HEIGHT); &#125; private enum ImageType &#123; CH("ch"), NL("nl"), N("n"), L("l"); private String createTypeFlag = null; ImageType(String createTypeFlag) &#123; this.createTypeFlag = createTypeFlag; &#125; public static ImageType getImageType(String createTypeFlag) &#123; if (createTypeFlag.equals("ch")) &#123; return CH; &#125; else if (createTypeFlag.equals("nl")) &#123; return NL; &#125; else if (createTypeFlag.equals("L")) &#123; return L; &#125; else &#123; return N; &#125; &#125; String getValue() &#123; return this.createTypeFlag; &#125; &#125;&#125; 运行结果如下： 二、在Form表单中使用验证码图片1234567891011121314151617181920212223&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg()&#123; document.getElementById("validateCodeImg").src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg" onclick="changeImg()"&gt; &lt;a href="javascript:void(0)" onclick="changeImg()"&gt;看不清，换一张&lt;/a&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： DrawImage Servlet除了可以生成的字母和数字的组合的验证码图片之外，还可以生成汉字，纯数字，纯字母的验证码图片，只需要向DrawImage Servlet传递约定好的生成标识符参数即可，如下所示： 12345678910111213141516171819202122232425262728293031&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type="text/javascript"&gt; //刷新验证码 function changeImg(obj,createTypeFlag)&#123; document.getElementById(obj.id).src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag="+createTypeFlag+"&amp;"+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; 数字字母混合验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage" id="validateCodeImg1" onclick="changeImg(this,'nl')"&gt; &lt;br/&gt; 中文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=ch" id="validateCodeImg2" onclick="changeImg(this,'ch')"&gt; &lt;br/&gt; 英文验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=l" id="validateCodeImg3" onclick="changeImg(this,'l')"&gt; &lt;br/&gt; 数字验证码：&lt;input type="text" name="validateCode"/&gt; &lt;img alt="验证码看不清，换一张" src="$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage?createTypeFlag=n" id="validateCodeImg4" onclick="changeImg(this,'n')"&gt; &lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下： 三、服务器端对form表单提交上来的验证码处理12345678910111213141516171819202122232425262728package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 服务器端接收到验证码后的处理 */public class CheckServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String clientCheckcode = request.getParameter("validateCode");//接收客户端浏览器提交上来的验证码 String serverCheckcode = (String) request.getSession().getAttribute("checkcode");//从服务器端的session中取出验证码 if (clientCheckcode.equals(serverCheckcode)) &#123;//将客户端验证码和服务器端验证比较，如果相等，则表示验证通过 System.out.println("验证码验证通过！"); &#125;else &#123; System.out.println("验证码验证失败！"); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、HttpServletResponse常见应用——生成验证码1.1、生成随机图片用作验证码 生成图片主要用到了一个BufferedImage类， 生成随机图片范例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package org.wuqinghua.java.ch04;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo05")public class ResponseDemo05 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置浏览器每隔5秒刷新一次 resp.setHeader("refresh", "5"); //1.在内存中创建一张图片 BufferedImage image = new BufferedImage(100, 25, BufferedImage.TYPE_INT_RGB); //2.绘制图片 获取画笔 Graphics2D g = (Graphics2D) image.getGraphics(); g.setColor(Color.WHITE);//设置图片的背景色 g.fillRect(0, 0, 100, 25);//填充背景 //3.向图片上写数值 g.setColor(Color.BLUE); g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(makeNum(),0,20); //4.设置浏览器以图片方式打开 resp.setHeader("content-type","image/jpeg"); //5.设置浏览器不缓存图片 resp.setDateHeader("expries",-1); resp.setHeader("Cache-Control","no-cache"); resp.setHeader("Pragma","no-cache"); //6.将图片写到浏览器 ImageIO.write(image,"jpg",resp.getOutputStream()); &#125; private String makeNum() &#123; Random random = new Random(); String num = random.nextInt(9999999) + ""; StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; 7 - num.length(); i++) &#123; buffer.append("0"); &#125; num = buffer.toString() + num; return num; &#125;&#125; 运行结果如下： 二、HttpServletResponse常见应用——设置响应头控制浏览器的行为2.1、设置http响应头控制浏览器禁止缓存当前文档内容123response.setDateHeader("expries", -1);response.setHeader("Cache-Control", "no-cache");response.setHeader("Pragma", "no-cache"); 2.2、设置http响应头控制浏览器定时刷新网页(refresh)1response.setHeader("refresh", "5");//设置refresh响应头控制浏览器每隔5秒钟刷新一次 2.3、通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置**302状态码和设置location响应头实现重定向** 例如： 1234567891011121314151617181920212223242526272829package gacl.response.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ResponseDemo04 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 1.调用sendRedirect方法实现请求重定向, * sendRedirect方法内部调用了 * response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); * response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); */ response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向 //response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); //response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 三、response细节问题 getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。 getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。 Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(七)--HttpServletResponse(一)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%83-HttpServletResponse-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。 一、HttpServletResponse对象介绍 HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 1.1、负责向客户端(浏览器)发送数据的相关方法 1.2、负责向客户端(浏览器)发送响应头的相关方法 1.3、负责向客户端(浏览器)发送响应状态码的相关方法 1.4、响应状态码的常量 HttpServletResponse定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量： 状态码404对应的常量 状态码200对应的常量 状态码500对应的常量 二、HttpServletResponse对象常见应用2.1、使用OutputStream流向客户端浏览器输出中文数据使用OutputStream流输出中文注意问题： 在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，比如：outputStream.write(“中国”.getBytes(“UTF-8”));使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出，此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？可以通过设置响应头控制浏览器的行为，例如：response.setHeader(“content-type”, “text/html;charset=UTF-8”);通过设置响应头控制浏览器以UTF-8的编码显示数据。 范例：使用OutputStream流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627282930313233package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.Charset;/** * Created by wuqinghua on 17/7/1. */@WebServlet(urlPatterns = "/responseDemo01")public class ResponseDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; ServletOutputStream outputStream = resp.getOutputStream();//获取输出流 resp.setContentType("text/html;charset=UTF-8");//通过响应头告诉浏览器需要使用utf-8显示数据 /** * data.getBytes()是一个将字符串转换为字节数组的过程，这个过程一定会查询码表， * 如果是中文操作系统，默认就会查询GB2312的码表， * 将字符串转换成字节数组的过程就是将中文字符转换为GB2312上对应的数字 * 比如： "中" 在GB2312上对应的数字为98 * "国" 为99 */ byte[] bytes = data.getBytes(Charset.forName("UTF-8")); outputStream.write(bytes); &#125;&#125; 运行结果如下： 客户端浏览器接收到数据后，就按照响应头上设置的字符编码来解析数据，如下所示： 2.2、使用PrintWriter流向客户端浏览器输出中文数据使用PrintWriter流输出中文注意问题： 在获取PrintWriter输出流之前首先使用”response.setCharacterEncoding(charset)”设置字符以什么样的编码输出到浏览器，如：response.setCharacterEncoding(“UTF-8”);设置将字符以”UTF-8”编码输出到客户端浏览器，然后再使用response.getWriter();获取PrintWriter输出流，这两个步骤不能颠倒，如下： 123456response.setCharacterEncoding("UTF-8");//设置将字符以"UTF-8"编码输出到客户端浏览器/*** PrintWriter out = response.getWriter();这句代码必须放在response.setCharacterEncoding("UTF-");之后* 否则response.setCharacterEncoding("UTF-8")这行代码的设置将无效，浏览器显示的时候还是乱码*/PrintWriter out = response.getWriter();//获取PrintWriter输出流 然后再使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头，控制浏览器以指定的字符编码编码进行显示，例如： 12//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码response.setHeader("content-type", "text/html;charset=UTF-8"); 除了可以使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头来控制浏览器以指定的字符编码编码进行显示这种方式之外，还可以用如下的方式来模拟响应头的作用 123456/*** 多学一招：使用HTML语言里面的&lt;meta&gt;标签来控制浏览器行为，模拟通过设置响应头控制浏览器行为 *response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;");* 等同于response.setHeader("content-type", "text/html;charset=UTF-8");*/response.getWriter().write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'/&gt;"); 范例：使用PrintWriter流向客户端浏览器输出”中国”这两个汉字 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo02")public class ResponseDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "中国"; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=utf-8"); PrintWriter out = resp.getWriter(); out.print(data); &#125;&#125; 当需要向浏览器输出字符数据时，使用PrintWriter比较方便，省去了将字符转换成字节数组那一步。 2.3、使用OutputStream或者PrintWriter向客户端浏览器输出数字比如有如下的代码： 123456789101112131415161718192021222324package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8")); outputStream.write(1); &#125;&#125; 运行上面代码显示的结果如下： 运行的结果和我们想象中的不一样，数字1没有输出来，下面我们修改一下上面的outputOneByOutputStream方法的代码，修改后的代码如下： 12345678910111213141516171819202122232425package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo03")public class ResponseDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setHeader("content-type","text/html;charset=utf-8"); OutputStream outputStream = resp.getOutputStream(); outputStream.write("使用outputStream向界面输出1:".getBytes("UTF-8"));// outputStream.write(1); outputStream.write((1+"").getBytes("UTF-8")); &#125;&#125; 1+””这一步是将数字1和一个空字符串相加，这样处理之后，数字1就变成了字符串1了，然后再将字符串1转换成字节数组使用OutputStream进行输出，此时看到的结果如下： 这次可以看到输出来的1了，这说明了一个问题：在开发过程中，如果希望服务器输出什么浏览器就能看到什么，那么在服务器端都要以字符串的形式进行输出。 如果使用PrintWriter流输出数字，那么也要先将数字转换成字符串后再输出，如下： 12345678910111213/** * 使用PrintWriter流输出数字1 * @param request * @param response * @throws IOException */ public void outputOneByPrintWriter(HttpServletResponse response) throws IOException&#123; response.setHeader("content-type", "text/html;charset=UTF-8"); response.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write("使用PrintWriter流输出数字1："); out.write(1+""); &#125; 2.4、文件下载 文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载 文件下载功能的实现思路： 1.获取要下载的文件的绝对路径 2.获取要下载的文件名 3.设置content-disposition响应头控制浏览器以下载的形式打开文件 4.获取要下载的文件输入流 5.创建数据缓冲区 6.通过response对象获取OutputStream流 7.将FileInputStream流写入到buffer缓冲区 8.使用OutputStream将缓冲区的数据输出到客户端浏览器 范例：使用Response实现文件下载 123456789101112131415161718192021222324252627282930313233343536373839package org.wuqinghua.java.ch04;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/7/2. */@WebServlet(urlPatterns = "/responseDemo04")public class ResponseDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取绝对路径 String realPath = this.getServletContext().getRealPath("/img/WP_20131005_002.jpg"); //2.获取文件的名称 String filename = realPath.substring(realPath.lastIndexOf("\\") + 1); //3.设置响应头content-disposition控制浏览器以下载的方式打开文件 resp.setHeader("content-disposition","attachment;filename="+filename); //4.获取文件的输入流 InputStream in = new FileInputStream(realPath); //5.获取输出流 OutputStream outputStream = resp.getOutputStream(); //6.将输入流写入到输出流中 byte[] buffer = new byte[4096]; int len = -1; while ((len=in.read(buffer,0,4096))!=-1)&#123; outputStream.write(buffer,0,len); &#125; outputStream.close(); &#125;&#125; 运行结果如下所示： 范例：**使用Response实现中文文件下载** 下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadChineseFileByOutputStream(response);//下载中文文件 &#125; /** * 下载中文文件,中文文件下载时，文件名要经过URL编码，否则会出现文件名乱码 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadChineseFileByOutputStream(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码，否则会出现文件名乱码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); InputStream in = new FileInputStream(realPath);//获取文件输入流 int len = 0; byte[] buffer = new byte[1024]; OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下所示： 文件下载注意事项：编写文件下载功能时推荐使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。 范例：使用PrintWriter流下载文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package gacl.response.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author gacl * 文件下载 */public class ResponseDemo02 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadFileByPrintWriter(response);//下载文件，通过PrintWriter流 &#125; /** * 下载文件，通过PrintWriter流，虽然也能够实现下载，但是会导致数据丢失，因此不推荐使用PrintWriter流下载文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void downloadFileByPrintWriter(HttpServletResponse response) throws FileNotFoundException, IOException &#123; String realPath = this.getServletContext().getRealPath("/download/张家界国家森林公园.JPG");//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf("\\")+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码 response.setHeader("content-disposition", "attachment;filename="+URLEncoder.encode(fileName, "UTF-8")); FileReader in = new FileReader(realPath); int len = 0; char[] buffer = new char[1024]; PrintWriter out = response.getWriter(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 运行结果如下： 正常弹出下载框，此时我们点击【保存】按钮将文件下载下来，如下所示： 可以看到，只下载了5.25MB，而这张图片的原始大小却是 这说明在下载的时候数据丢失了，所以下载不完全，所以这张图片虽然能够正常下载下来，但是却是无法打开的，因为丢失掉了部分数据，如下所示： 所以使用PrintWriter流处理字节数据，会导致数据丢失，这一点千万要注意，因此在编写下载文件功能时，要使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(六)--Servlet开发(二)]]></title>
    <url>%2F2017%2F06%2F30%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%85%AD-Servlet%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、ServletConfig讲解1.1、通过ServletConfig获取Servlet的初始化参数 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 ​ 例如: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package org.wuqinghua.java.ch01;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;/** * Created by wuqinghua on 17/6/30. */@WebServlet(name = "servletConfigDemo01",urlPatterns = &#123;"/servletConfigDemo01"&#125;,initParams =&#123;@WebInitParam(name = "name",value = "gacl"),@WebInitParam(name = "password",value = "123"),@WebInitParam(name = "charset",value = "UTF-8")&#125; )public class ServletConfigDemo01 extends HttpServlet &#123; //定义ServletConfig对象来接受配置的初始化参数 private ServletConfig servletConfig; /** *当servlet配置了初始化参数后，web容器在创建servlet实例对象时， * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时， * 将servletConfig对象传递给servlet。进而，通过ServletConfig对象就可以得到初始化数据 */ @Override public void init(ServletConfig config) throws ServletException &#123; this.servletConfig = config; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取配置的参数 String paramVal = this.servletConfig.getInitParameter("name"); resp.getWriter().print(paramVal); resp.getWriter().print("&lt;hr /&gt;"); //获取所有初始化参数 Enumeration&lt;String&gt; e = this.servletConfig.getInitParameterNames(); while (e.hasMoreElements())&#123; String name = e.nextElement(); String value = this.servletConfig.getInitParameter(name); resp.getWriter().print(name+"-"+value+"&lt;br /&gt;"); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 运行结果如下： 二、ServletContext对象 WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 三、ServletContext的应用 3.1、多个Servlet通过ServletContext对象实现数据共享 范例：ServletContextDemo1和ServletContextDemo2通过ServletContext对象实现数据共享 1234567891011121314151617181920212223242526272829303132333435package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo01",initParams = @WebInitParam(name = "name",value = "hello"))public class ServletContextDemo01 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "xdp_gacl"; /** * 获取ServletContext */ ServletContext servletContext = this.getServletConfig().getServletContext(); ServletContext servletContext1 = this.getServletContext(); System.out.println(servletContext == servletContext1); System.out.println(this.getServletConfig().getInitParameter("name")); servletContext.setAttribute("data", data); &#125;&#125; 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo02")public class ServletContextDemo02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); String data = (String) servletContext.getAttribute("data"); resp.getWriter().print("data="+data); &#125;&#125; 先运行ServletContextDemo1，将数据data存储到ServletContext对象中，然后运行ServletContextDemo2就可以从ServletContext对象中取出数据了，这样就实现了数据共享，如下图所示： 3.2、获取WEB应用的初始化参数 在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示： 1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;&lt;/context-param&gt; 获取参数代码： 1234567891011121314151617181920212223package org.wuqinghua.java.ch01;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet("/servletContextDemo03")public class ServletContextDemo03 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取servletContext ServletContext servletContext = this.getServletContext(); String url = servletContext.getInitParameter("url"); resp.getWriter().print(url); &#125;&#125; 运行结果： 3.3、用servletContext实现请求转发1234567891011121314151617181920212223242526package org.wuqinghua.java.ch01;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = &#123;"/servletContextDemo04"&#125;)public class ServletContextDemo04 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "&lt;h1&gt;&lt;font color='red'&gt;abcdefghijkl&lt;/font&gt;&lt;/h1&gt;"; resp.getOutputStream().write(data.getBytes()); ServletContext servletContext = this.getServletContext(); RequestDispatcher rd = servletContext.getRequestDispatcher("/servletContextDemo05"); rd.forward(req,resp); &#125;&#125; 12345678910111213141516171819package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/30. */@WebServlet(urlPatterns = "/servletContextDemo05")public class ServletContextDemo05 extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getOutputStream().write("servletContextDemo05".getBytes()); &#125;&#125; 运行结果： 访问的是ServletContextDemo4，浏览器显示的却是ServletContextDemo5的内容，这就是使用ServletContext实现了请求转发 3.4、利用ServletContext对象读取资源文件项目目录结构如下： 代码范例：使用servletContext读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package gacl.servlet.study;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 使用servletContext读取资源文件 * * @author gacl * */public class ServletContextDemo6 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); readSrcDirPropCfgFile(response);//读取src目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readWebRootDirPropCfgFile(response);//读取WebRoot目录下的properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile(response);//读取src目录下的db.config包中的db3.properties配置文件 response.getWriter().println("&lt;hr/&gt;"); readPropCfgFile2(response);//读取src目录下的gacl.servlet.study包中的db4.properties配置文件 &#125; /** * 读取src目录下的gacl.servlet.study包中的db4.properties配置文件 * @param response * @throws IOException */ private void readPropCfgFile2(HttpServletResponse response) throws IOException &#123; InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取src目录下的db.config包中的db3.properties配置文件 * @param response * @throws FileNotFoundException * @throws IOException */ private void readPropCfgFile(HttpServletResponse response) throws FileNotFoundException, IOException &#123; //通过ServletContext获取web资源的绝对路径 String path = this.getServletContext().getRealPath("/WEB-INF/classes/db/config/db3.properties"); InputStream in = new FileInputStream(path); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db.config包中的db3.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * @param response * @throws IOException */ private void readWebRootDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * “/”代表的是项目根目录 */ InputStream in = this.getServletContext().getResourceAsStream("/db2.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取WebRoot目录下的db2.properties配置文件："); response.getWriter().print( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过ServletContext对象读取src目录下的properties配置文件 * @param response * @throws IOException */ private void readSrcDirPropCfgFile(HttpServletResponse response) throws IOException &#123; /** * 通过ServletContext对象读取src目录下的db1.properties配置文件 */ InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 代码范例：使用类装载器读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package gacl.servlet.study;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.text.MessageFormat;import java.util.Properties;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 用类装载器读取资源文件 * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 * @author gacl * */public class ServletContextDemo7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * response.setContentType("text/html;charset=UTF-8");目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader("content-type","text/html;charset=UTF-8"); test1(response); response.getWriter().println("&lt;hr/&gt;"); test2(response); response.getWriter().println("&lt;hr/&gt;"); //test3(); test4(); &#125; /** * 读取类路径下的资源文件 * @param response * @throws IOException */ private void test1(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的db1.properties配置文件 InputStream in = loader.getResourceAsStream("db1.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的db1.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 读取类路径下面、包下面的资源文件 * @param response * @throws IOException */ private void test2(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo7.class.getClassLoader(); //用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件 InputStream in = loader.getResourceAsStream("gacl/servlet/study/db4.properties"); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); response.getWriter().println("用类装载器读取src目录下的gacl.servlet.study包中的db4.properties配置文件："); response.getWriter().println( MessageFormat.format( "driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;", driver,url, username, password)); &#125; /** * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 */ public void test3() &#123; /** * 01.avi是一个150多M的文件，使用类加载器去读取这个大文件时会导致内存溢出： * java.lang.OutOfMemoryError: Java heap space */ InputStream in = ServletContextDemo7.class.getClassLoader().getResourceAsStream("01.avi"); System.out.println(in); &#125; /** * 读取01.avi,并拷贝到e:\根目录下 * 01.avi文件太大，只能用servletContext去读取 * @throws IOException */ public void test4() throws IOException &#123; // path=G:\Java学习视频\JavaWeb学习视频\JavaWeb\day05视频\01.avi // path=01.avi String path = this.getServletContext().getRealPath("/WEB-INF/classes/01.avi"); /** * path.lastIndexOf("\\") + 1是一个非常绝妙的写法 */ String filename = path.substring(path.lastIndexOf("\\") + 1);//获取文件名 InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/01.avi"); byte buffer[] = new byte[1024]; int len = 0; OutputStream out = new FileOutputStream("e:\\" + filename); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, len); &#125; out.close(); in.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 运行结果如下： 四、在客户端缓存Servlet的输出 对于不经常变化的数据，在servlet中可以为其设置合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能。例如： 1234567891011121314151617181920212223242526272829package gacl.servlet.study;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo5 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "abcddfwerwesfasfsadf"; /** * 设置数据合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能 * 这里是将数据的缓存时间设置为1天 */ response.setDateHeader("expires",System.currentTimeMillis() + 24 * 3600 * 1000); response.getOutputStream().write(data.getBytes()); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(五)--Servlet开发(一)]]></title>
    <url>%2F2017%2F06%2F29%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%94-Servlet%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Servlet简介 Servlet是sun公司提供的一门用于开发动态web资源的技术。 Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二、Servlet的运行过程Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后： ①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ②装载并创建该Servlet的一个实例对象。 ③调用Servlet实例对象的init()方法。 ④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 ⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 三、Servlet调用图 四、在Eclipse中开发Servlet 在eclipse中新建一个web project工程，eclipse会自动创建下图所示目录结构： 4.1、Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。 4.2、通过Eclipse创建和编写Servlet 选中gacl.servlet.study包，右键→New→Servlet，如下图所示： 这样，我们就通过Eclipse帮我们创建好一个名字为ServletDemo1的Servlet，创建好的ServletDemo01里面会有如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package gacl.servlet.study; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;public class ServletDemo1 extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the GET method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the POST method"); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125;&#125; 这些代码都是Eclipse自动生成的，而web.xml文件中也多了和两对标签，这两对标签是配置ServletDemo1的，如下图所示： 然后我们就可以通过浏览器访问ServletDemo1这个Servlet，如下图所示： 五、Servlet开发注意细节5.1、Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用元素和元素完成。 元素用于注册Servlet，它包含有两个主要的子元素：和，分别用于设置Servlet的注册名称和Servlet的完整类名。一个元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：和，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如： 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 例如： 12345678910111213141516171819202122232425 &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/1.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/2.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/3.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/4.ASPX&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面的配置，当我们想访问名称是ServletDemo1的Servlet，可以使用如下的几个地址去访问： http://localhost:8080/JavaWeb_Servlet_Study_20140531**/servlet/ServletDemo1** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/1.htm** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/2.jsp** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/3.php** http://localhost:8080/JavaWeb_Servlet_Study_20140531**/4.ASPX** ServletDemo1被映射到了多个URL上。 5.2、Servlet访问URL使用*通配符映射 在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是”.扩展名”，另一种格式是以正斜杠（/）开头并以”/“结尾。例如： 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; *可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet，如下图所示： 对于如下的一些映射关系： Servlet1 映射到 /abc/ Servlet2 映射到 / Servlet3 映射到 /abc Servlet4 映射到 .do问题： 当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/abc/”和“/abc”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，哪个servlet响应​ Servlet引擎将调用Servlet2。 匹配的原则就是”谁长得更像就找谁” 5.3、Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 如果在元素中配置了一个元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。​ 举例：​ ​ invoker​ ​ org.apache.catalina.servlets.InvokerServlet​ ​ 1​ 用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。 5.4、缺省Servlet 如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 凡是在web.xml文件中找不到匹配的元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。 例如： 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo2&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示： 在\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。 12345678910111213141516171819 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。 5.5、Servlet的线程安全问题 当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码： 不存在线程安全问题的代码： 12345678910111213141516171819202122232425262728293031323334 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗 * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量， * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量， * 各个线程操作的都是自己的i变量，所以不存在线程安全问题 * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等) * 那么每一个线程都有这些东西，所以就不存在线程安全问题了 */ int i=1; i++; response.getWriter().write(i); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 存在线程安全问题的代码： 123456789101112131415161718192021222324252627282930package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了，如下图所示：同时开启两个浏览器模拟并发访问同一个Servlet，本来正常来说，第一个浏览器应该看到2，而第二个浏览器应该看到3的，结果两个浏览器都看到了3，这就不正常。 线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？ 先看看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041 package gacl.servlet.study; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ServletDemo3 extends HttpServlet &#123; int i=1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 加了synchronized后，并发访问i时就不存在线程安全问题了， * 为什么加了synchronized后就没有线程安全问题了呢？ * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁 * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁， * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了 * */ synchronized (this) &#123;//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象 i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+""); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了，如下图所示： 这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。 针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。 查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。 让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。 实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(四)--Http协议]]></title>
    <url>%2F2017%2F06%2F28%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%9B%9B-Http%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 一、什么是HTTP协议 HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 二、HTTP协议的版本 HTTP协议的版本：HTTP/1.0、HTTP/1.1 三、HTTP1.0和HTTP1.1的区别 在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。 在HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 四、HTTP请求4.1、HTTP请求包括的内容 客户端连上服务器后，向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。 一个完整的HTTP请求包括如下内容：一个请求行、若干消息头、以及实体内容范例： 4.2、HTTP请求的细节——请求行 请求行中的GET称之为请求方式，请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST 用户如果没有设置，默认情况下浏览器向服务器发送的都是get请求，例如在浏览器直接输地址访问，点超链接访问等都是get，用户如想把请求方式改为post，可通过更改表单的提交方式实现。 不管POST或GET，都用于向服务器请求某个WEB资源，这两种方式的区别主要表现在数据传递上：如果请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如：GET /mail/1.html?name=abc&amp;password=xyz HTTP/1.1 GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 如果请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，Post方式的特点：传送的数据量无限制。 4.3、HTTP请求的细节——消息头 HTTP请求中的常用消息头 accept:浏览器通过这个头告诉服务器，它所支持的数据类型 Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集 Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式 Accept-Language：浏览器通过这个头告诉服务器，它的语言环境 Host：浏览器通过这个头告诉服务器，想访问哪台主机 If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间 Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的 防盗链 Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接 例如： 12345678Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*Referer: http://localhost:8080/JavaWebDemoProject/Web/2.jspAccept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; InfoPath.3)Accept-Encoding: gzip, deflateHost: localhost:8080Connection: Keep-Alive 五、HTTP响应5.1、HTTP响应包括的内容 一个HTTP响应代表服务器向客户端回送的数据，它包括： 一个状态行、若干消息头、以及实体内容 。 范例： 1234567891011121314 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 105 Date: Tue, 27 May 2014 16:23:28 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 5.2、HTTP响应的细节——状态行 状态行格式： HTTP版本号 状态码 原因叙述​ 举例：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类，如下所示： 5.3、HTTP响应细节——常用响应头 HTTP响应中的常用响应头(消息头) Location: 服务器通过这个头，来告诉浏览器跳到哪里 Server：服务器通过这个头，告诉浏览器服务器的型号 Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式 Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度 Content-Language: 服务器通过这个头，告诉浏览器语言环境 Content-Type：服务器通过这个头，告诉浏览器回送数据的类型 Refresh：服务器通过这个头，告诉浏览器定时刷新 Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据 Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的 Expires: -1 控制浏览器不要缓存 Cache-Control: no-cache Pragma: no-cache 六、在服务端设置响应头来控制客户端浏览器###6.1、设置Location响应头，实现请求重定向 123456789101112131415161718192021222324252627package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/27. * 设置Location响应头，实现请求重定向 */public class ServletDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setStatus(302);//设置服务器的响应状态码 /** *设置响应头，服务器通过Location这个头，来告诉浏览器跳到哪里，这就是所谓的请求的重定向 */ resp.setHeader("Location","/JavaWeb_HttpProtocol_Study_20140528/1.jsp"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 当在浏览器中使用URL地址”http://localhost:8080/JavaWeb_HttpProtocol_Study_20140528/servlet/ServletDemo01&quot;访问ServletDemo01时，就可以看到服务器作出响应后发送到浏览器的状态码和响应头信息，如下图所示： 服务器返回一个302状态码告诉浏览器，你要的资源我没有，但是我通过Location响应头告诉你哪里有，而浏览器解析响应头Location后知道要跳转到/JavaWeb_HttpProtocol_Study_20140528/1.jsp页面，所以就会自动跳转到1.jsp，如下图所示： 6.2、设置Content-Encoding响应头，告诉浏览器数据的压缩格式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.wuqinghua.java.ch01;import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.zip.GZIPOutputStream;/** * Created by wuqinghua on 17/6/29. * 这个程序主要两个知识点 * 1.使用GZIPOutputStream流来压缩数据 * 2.通过响应头Content-Encoding来告诉浏览器，服务器端发送的数据压缩格式 */public class ServletDemo02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String data = "abcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabc" + "dabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdab" + "cdabcdabcdabcdabcdabcdabcdabcdabcdabcd"; System.out.println("原始数据大小:"+data.getBytes().length); ByteOutputStream bout = new ByteOutputStream(); GZIPOutputStream gout = new GZIPOutputStream(bout); gout.write(data.getBytes()); gout.close(); //获取压缩后的数据 byte[] g = bout.toByteArray(); resp.setHeader("Content-Encoding","gzip"); resp.setHeader("Content-Length",g.length+""); resp.getOutputStream().write(g); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： 浏览器支持的压缩格式有： 6.3、设置Content-type响应头，指定回送数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 浏览器能接收(Accept)的数据类型有: * application/x-ms-application, * image/jpeg, * application/xaml+xml, * image/gif, * image/jpeg, * application/x-ms-xbap, * application/vnd.ms-excel, * application/vnd.ms-powerpoint, * application/msword, */ resp.setHeader("Content-type", "image/jpeg");//使用content-type响应头指定发送给浏览器的数据类型为image/jpeg //读入图片 InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 服务器发给浏览器的响应信息如下： ServletDemo03的运行结果如下图所示： 在浏览器中显示出了图片 6.4、设置refresh响应头，让浏览器定时刷新1234567891011121314151617181920212223242526272829303132package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo04",urlPatterns = &#123;"/servletDemo04"&#125;)public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置refresh响应头，让浏览器每隔3秒定时刷新 */// resp.setHeader("refresh","3"); /** * 设置refresh响应头，让浏览器3秒后跳转到http://www.baidu.com */ resp.setHeader("refresh", "3;url='http://www.baidu.com'"); resp.getWriter().write("gacl"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 6.5、设置content－disposition响应头，让浏览器下载 123456789101112131415161718192021222324252627282930313233343536package org.wuqinghua.java.ch01;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * Created by wuqinghua on 17/6/29. */@WebServlet(name = "servletDemo05", urlPatterns = &#123;"/servletDemo05"&#125;)public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; /** * 设置content－disposition响应头，让浏览器下载文件 */ resp.setHeader("content-disposition", "attachment;filename=xxx.jpg"); InputStream in = this.getServletContext().getResourceAsStream("/img/WP_20131005_002.jpg"); byte buffer[] = new byte[1024]; int len = -1; OutputStream out = resp.getOutputStream(); while ((len = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, len); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 在浏览器中访问ServletDemo05就会弹出文件下载框，如下图所示：]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(三)——Tomcat服务器学习和使用(二)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一、打包JavaWeb应用 在Java中，使用”jar”命令来对将JavaWeb应用打包成一个War包，jar命令的用法如下： 范例：将JavaWebDemoProject这个JavaWeb应用打包成war包 执行完之后，就可以得到一个文件，平时开发完JavaWeb应用后，一般都会将JavaWeb应用打包成一个war包，然后将这个war包放到Tomcat服务器的webapps目录下，当Tomcat服务器启动时，就会自动将webapps目录下的war包解压。 比如现在将放到放到Tomcat服务器的webapps目录下 Tomcat服务器启动后会自动”Deploying web application”，将这个war文件解压缩，如下图所示： 二、Tomcat的体系结构 Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个”Connector(连接器)”，每一个连接器都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理，Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host，Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。 1234567891011121314151617181920212223242526&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;Host name="www.gacl.cn" appBase="F:\JavaWebApps"&gt; &lt;Context path="" docBase="F:\JavaWebApps\JavaWebDemo1"/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 三、互联网上的加密原理 Tomcat服务器启动时候会启动多个Connector(连接器)，而Tomcat服务器的连接器又分为加密连接器和非加密连机器，比如： 这里访问的就是使用8080端口的那个连接器 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这个Connector是一个没有加密的连接器，使用”http://localhost:8080/JavaWebDemoProject/Web/1.jsp&quot;去请求服务器上的web资源的这个过程中，我们的请求是不加密的，要是想以一种加密的方式来访问Tomcat服务器，那么就要在Tomcat里面配置一个加密的Connector。要配置一个加密连接器，首先应该把互联网上的加密原理弄清楚。 3.1、对称加密 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。 常用的对称加密有：DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES算法等 3.2、非对称加密 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 非对称加密工作原理 1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。 2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。 3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。 4.A将这个消息发给B（已经用B的公钥加密消息）。 5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥 发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样，信息就可以安全无误地到达目的地了，即使被第三方截获，由于没有相应的私钥，也无法进行解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。 非对称性加密依然没有解决数据传输的安全性问题，比如A想向B发数据，B首先生成一对密钥(公钥和私钥)，然后将公钥发给A，A拿到B发给他的公钥有就可以使用公钥加密数据后发给B，然而在B公钥发送给A的这个过程中，很有可能会被第三方C截获，C截获到B的公钥后，也使用B的公钥加密数据，然后发给B，B接收到数据后就晕了，因为搞不清楚接收到的数据到底是A发的还是C发的，这是其中一个问题，另一个问题就是，C截获到B发的公钥后，C可以自己生成一对密钥(公钥和私钥)，然后发给A，A拿到公钥后就以为是B发给他的，然后就使用公钥加密数据发给B，发送给B的过程中被C截获下来，由于A是用C发给他的公钥加密数据的，而C有私钥，因此就可以解密A加密过后的内容了，而B接收到A发给他的数据后反而解不开了，因为数据是用C的公钥加密的，B没有C的私钥，所以就无法解密。所以，非对称性加密存在一个问题：A想向B发数据，A如何确定拿到的公钥一定是B发的呢？那么如何解决这个问题呢？只能靠一个第三方机构(CA机构，即证书授权中心(Certificate Authority )，或称证书授权机构)来担保。A想向B发数据，B首先将公钥发给CA机构，CA机构拿到B的公钥后跑到B的家里问：这是你发的公钥吗？B确认过后说是：没错，是我发的！那么此时CA机构就会为B的公钥做担保，生成一份数字证书给B，数字证书包含了CA的担保认证签名和B的公钥，B拿到CA的这份数字证书后，就发给A，A拿到数字证书后，看到上面有CA的签名，就可以确定当前拿到的公钥是B发的，那么就可以放心大胆地使用公钥加密数据，然后发给B了。 四、https连接器 明白了互联网上的加密原理之后，下面来看看浏览器与服务器交互时，浏览器想将数据加密后再发送给服务器，那么该怎么做呢？服务器首先要向浏览器出示一份数字证书，浏览器看到数字证书后，就可以使用数字证书里面的公钥加密数据，所以要想做浏览器和服务器的加密数据传输，那么首先得针对服务器生成一份数字证书。然后再配置一下服务器，让服务器收到浏览器的请求之后，会向浏览器出示它的数字证书。 4.1、生成Tomcat服务器的数字证书 SUN公司提供了制作证书的工具keytool， 在JDK 1.4以后的版本中都包含了这一工具，它的位置为\bin\keytool.exe 1keytool -genkey -alias tomcat -keyalg RSA 使用keytool生成一个名字为tomcat的证书，存放在.keystore这个密钥库中 命令执行完之后，操作系统的用户文件夹下面就会生成一个.keystore文件，如下图所示： 使用命令：keytool -list -keystore .keystore查看.keystore密钥库里面的所有证书 4.2、配置https连接器 将生成的.keystore密钥库文件拷贝到Tomcat服务器的conf目录下，如下图所示： 修改server.xml文件，配置https连接器，代码如下： 1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="conf/.keystore" keystorePass="123456"/&gt; 在server.xml文件中配置了一个端口是8443的加密连接器，浏览器访问8443端口的连接器时，将会以加密的方式来访问web服务器，这个连接器收到浏览器的请求后，将会向浏览器出示一份数字证书，浏览器再用数字证书里面的公钥来加密数据，keystoreFile=”conf/.keystore” 用来指明密钥库文件的所在路径，服务器从密钥库中提取证书时需要密码，keystorePass=”123456”指明密钥库的访问密码。 使用”https://localhost:8443/&quot;访问8443的加密连接器 由于密钥库里面的证书是我们手工生成的，没有经过CA的认证，所以使用”https://localhost:8443/“ 访问8443的加密连接器，浏览器会出现”证书错误，导航已阻止”，浏览器认为当前要访问的这个主机是不安全的，不推荐继续访问，点击就可以继续访问了，如下图所示： 4.3、安装数字证书 为了让浏览器信任我们生成的数字证书，需要将数字证书安装到浏览器中，以IE8浏览器为例进行证书安装说明，安装步骤如下： 证书安装成功后，重启IE浏览器，使用”https://localhost:8443/&quot;访问8443的加密连接器，此时浏览器就不再提示证书错误了，如下图所示： 4.4、删除数字证书 以IE8为例进行说明，操作步骤如下：工具—–&gt;Internet选项 删除之后重启浏览器即可]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(二)--Tomcat服务器学习使用(一)]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C-Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 一、Tomcat服务器端口的配置 Tomcat的所有配置都放在conf文件夹之中，里面的server.xml文件是配置的核心文件。 如果想修改Tomcat服务器的启动端口，则可以在server.xml配置文件中的Connector节点进行的端口修改 例如：将Tomcat服务器的启动端口由默认的8080改成8081端口 Tomcat服务器启动端口默认配置 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 将Tomcat服务器启动端口修改成8081端口 123&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 这样就把原来默认Tomcat默认的的8080端口改成了8081端口了，需要注意的是，一旦服务器中的*.xml文件改变了，则Tomcat服务器就必须重新启动，重新启动之后将重新读取新的配置信息。因为已经在server.xml文件中将Tomcat的启动端口修改成了8081，所以Tomcat服务器启动时就以8081端口启动了，如下图所示： 访问Tomcat服务器也必须以新的访问端口去访问：http://localhost:8081/，如下图所示： 二、Tomcat服务器虚拟目录的映射方式 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。那么在Tomcat服务器中，如何进行虚拟目录的映射呢？总共有如下的几种方式： 2.1、虚拟目录的映射方式一：在server.xml文件的host元素中配置找到server.xml文件的host元素，如下图所示： 在这对标签加上即可将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”，代码如下： 123456&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;/JavaWebApp&quot; docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; &lt;/Host&gt; 其中，Context表示上下文，代表的就是一个JavaWeb应用，Context元素有两个属性， Ⅰ.path：用来配置虚似目录，必须以”/“开头。 Ⅱ.docBase：配置此虚似目录对应着硬盘上的Web应用所在目录。 使用浏览器访问”/JavaWebApp”这个虚拟目录下的1.jsp这个web资源，访问结果如下： 1.jsp可以正常访问，这说明我们已经成功地将将在F盘下的JavaWebDemoProject这个JavaWeb应用映射到JavaWebApp这个虚拟目录上了，访问”/JavaWebApp/1.jsp”就相当于访问”F:\JavaWebDemoProject\1.jsp” 注意：在Tomcat6之后中，不再建议在server.xml文件中使用配置context元素的方式来添加虚拟目录的映射，因为每次修改server.xml文件后，Tomcat服务器就必须要重新启动后才能重新加载server.xml文件。在Tomcat服务器的文档http://localhost:8080/docs/config/context.html中有这样的说明： It is NOT recommended to place elements directly in the server.xml file. This is because it makes modifying the Context configuration more invasive since the main conf/server.xml file cannot be reloaded without restarting Tomcat. Individual Context elements may be explicitly defined: In an individual file at /META-INF/context.xml inside the application files. Optionally (based on the Host’s copyXML attribute) this may be copied to $CATALINA_BASE/conf/[enginename]/[hostname]/ and renamed to application’s base file name plus a “.xml” extension. In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. Inside a Host element in the main conf/server.xml. 2.2、虚拟目录的映射方式二：让tomcat服务器自动映射 tomcat服务器会自动管理webapps目录下的所有web应用，并把它映射成虚似目录。换句话说，tomcat服务器webapps目录中的web应用，外界可以直接访问。 例如：把F盘下的JavaWebDemoProject这个JavaWeb应用直接copy到tomcat服务器webapps目录中，如下图所示： 此时Tomcat服务器就会自动为JavaWebDemoProject这个JavaWeb应用映射一个同名的虚拟目录”/JavaWebDemoProject”，然后就可以使用浏览器访问这个JavaWeb应用的资源了，如下图所示： 2.3、虚拟目录的映射方式三 参考Tomcat服务器文档： In individual files (with a “.xml” extension) in the $CATALINA_BASE/conf/[enginename]/[hostname]/ directory. The context path and version will be derived from the base name of the file (the file name less the .xml extension). This file will always take precedence over any context.xml file packaged in the web application’s META-INF directory. 意思就是：在tomcat服务器的\conf\Catalina\localhost目录下添加一个以xml作为扩展名的文件，xml文件的名字可以任意取，比如下面的aa.xml，注意这一句话”The context path and version will be derived from the base name of the file“，这一句话的意思翻译过来就是”context元素的path属性源自于是这个xml文件的名字”，上面提到过，Context元素的path属性是用来配置虚似目录的名称的，所以虚似目录的名称就是这个xml文件的名称。 $CATALINA_BASE指的就是tomcat服务器根目录，[enginename]指的是Tomcat服务器使用的引擎名称，Tomcat使用的引擎是Catalina 在aa.xml文件中添加Context元素映射JavaWeb应用，代码如下： 11 &lt;Context docBase=&quot;F:\JavaWebDemoProject&quot; /&gt; 注意：在Context元素中并没有指明path属性来设置虚拟目录的名称，那么”F:\JavaWebDemoProject”映射的虚拟目录名称是神马呢，就是当前正在编辑的这个xml文件的名称aa。 使用这种方式映射虚拟目录的最大好处是修改了配置文件后不用重启Tomcat服务器，比如将aa.xml修改成bb.xml，Tomcat服务器会自动Undeploying context [/aa]，然后自动信息: Deploying configuration descriptor D:\apache-tomcat-7.0.53\conf\Catalina\localhost\bb.xml 三、Tomcat服务器配置虚似主机3.1、配置虚拟主机 配置虚似主机就是配置一个网站。 在Tomcat服务器配置一个虚拟主机(网站)，需要修改conf文件夹下的server.xml这个配置文件，使用Host元素进行配置，打开server.xml，可以看到Tomcat服务器自带的一个名称为localhost的虚拟主机(网站)，如下图所示： 平时我们将开发好的JavaWeb应用放到webapps文件夹下，然后就可以使用”http://localhost:端口号/JavaWebAppName“的方式去访问了，其实访问的就是name是”localhost”的那台虚拟主机(Host)，这台虚拟主机管理webapps文件夹下的所有web应用。 例如：http://localhost:8080/JavaWebDemoProject/1.jsp，这个URL地址访问的就是名称是localhost的那台虚拟主机下的JavaWebDemoProject这个应用里面的1.jsp这个web资源。 我们可以使用如下的方式配置一个虚拟主机，例如： 123&lt;Host name=&quot;www.gacl.cn&quot; appBase=&quot;F:\JavaWebApps&quot;&gt; &lt;/Host&gt; 这里我们新配置一个虚拟主机，虚拟主机的name是”www.gacl.cn”，虚拟主机”www.gacl.cn”现在管理着JavaWebApps文件夹下的所有web应用，平时我们在互联网上使用域名”www.baidu.com”访问百度的网站时，其实就是在访问一个名称是”www.baidu.com”的虚拟主机，所以当我们要访问name是”www.gacl.cn”的这个虚拟主机时，就可以使用”域名(www.gacl.cn)”去访问，注意一下appBase=”F:\JavaWebApps”，这里的JavaWebApps文件夹代表的不是一个项目的根目录，而是一个存放了一个或者多个JavaWeb应用的文件夹，如下图所示： 就好像是Tomcat服务器的webapps文件夹一样，里面存放了很多的JavaWeb应用 3.2、windows系统中注册域名 配置的主机(网站)要想通过域名被外部访问，必须在DNS服务器或windows系统中注册访问网站时使用的域名，找到”C:\Windows\System32\drivers\etc“目录下的hosts文件，如下图所示： 编辑这个文件，将新添加的网站的域名和IP地址绑定在一起，这样我们就可以在浏览器中使用www.gacl.cn这个域名去访问name是www.gacl.cn那个虚拟主机里面管理的那些web应用了 使用浏览器通过域名”www.gacl.cn”访问”www.gacl.cn”这个虚拟主机下的JavaWebDemo1这个web应用下的1.jsp这个web资源，”www.gacl.cn”这个虚拟主机开放了一个8080端口，用户只能通过这个8080端口去访问JavaWebDemo1这个web应用下的1.jsp这个web资源 四、浏览器与服务器交互的过程4.1、浏览器与服务器交互图 当我们打开浏览器，在浏览器的地址栏中输入URL地址”http://www.gacl.cn:8080/JavaWebDemo1/1.jsp&quot;去访问服务器上的1.jsp这个web资源的过程中，浏览器和服务器都做了神马操作呢，我们是怎么在浏览器里面看到1.jsp这个web资源里面的内容的呢？ 浏览器和服务器做了以下几个操作： 1、浏览器根据主机名”www.gacl.cn”去操作系统的Hosts文件中查找主机名对应的IP地址。 2、浏览器如果在操作系统的Hosts文件中没有找到对应的IP地址，就去互联网上的DNS服务器上查找”www.gacl.cn”这台主机对应的IP地址。 3、浏览器查找到”www.gacl.cn”这台主机对应的IP地址后，就使用IP地址连接到Web服务器。 4、浏览器连接到web服务器后，就使用http协议向服务器发送请求，发送请求的过程中，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源，如下图所示： 这就是浏览器向Web服务器发请求时向服务器传输的数据，解释一下”GET /JavaWebDemo1/1.jsp HTTP/1.1“这里面的内容， GET：告诉Web服务器，浏览器是以GET的方式向服务器发请求。 /JavaWebDemo1/1.jsp：告诉Web服务器，浏览器要访问JavaWebDemo1应用里面的1.jsp这个Web资源。 HTTP/1.1：告诉Web服务器，浏览器是以HTTP协议请求的，使用的是1.1的版本。 5、浏览器做完上面4步工作后，就开始等待，等待Web服务器把自己想要访问的1.jsp这个Web资源传输给它。 6、服务器接收到浏览器传输的数据后，开始解析接收到的数据，服务器解析”GET /JavaWebDemo1/1.jsp HTTP/1.1“里面的内容时知道客户端浏览器要访问的是JavaWebDemo1应用里面的1.jsp这个Web资源，然后服务器就去读取1.jsp这个Web资源里面的内容，将读到的内容再以Stream(流)的形式传输给浏览器，如下图所示： 这个就是Web服务器传输给浏览器的数据。 7、浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了，如下图所示： 看到的这个”JavaWebDemo1”就是浏览器解析服务器发送回来的数据后的效果 服务器发送回来的数据： ;) 123456789101112131415 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 102 Date: Mon, 19 May 2014 14:25:14 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;JavaWebDemo1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; JavaWebDemo1 &lt;/body&gt;&lt;/html&gt; ;) 这就是浏览器和服务器的交互过程。 五、JavaWeb应用的组成结构 开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错 WebRoot →Web应用所在目录，一般情况下虚拟目录要配置到此文件夹当中。 ┝WEB-INF：此文件夹必须位于**WebRoot文件夹里面，而且必须以这样的形式去命名，字母都要大写。** ┝web.xml：配置文件，有格式要求，此文件必须以这样的形式去命名，并且必须放置到**WEB-INF文件夹中。** web.xml的格式可以直接从Tomcat中参考得到：找到Tomcat目录下的webapps\ROOT\WEB-INF这个目录下的web.xml文件，把这个文件拷贝到我们新建的WEB-INF文件夹中，并修改这个web.xml文件，把里面的注释删除掉，只留下如下所示的代码即可： web.xml : 123456789101112 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Welcome to Tomcat&lt;/display-name&gt; &lt;description&gt; Welcome to Tomcat &lt;/description&gt;&lt;/web-app&gt; 这就是web.xml这个文件的格式]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习总结(一)--JavaWeb开发入门]]></title>
    <url>%2F2017%2F06%2F27%2FJavaWeb%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%80-JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 一.基本概念1.1、WEB开发相关知识WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在Java中，动态web资源开发技术统称为Javaweb。 1.2、WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 1.3、WEB发展史 WEB发展的两个阶段：静态、动态 1.4、静态WEB htm、html，这些是网页的后缀，如果现在在一个服务器上直接读取这些内容，那么意味着是把这些网页的内容通过网络服务器展现给用户。整个静态WEB操作的过程图如下： 在静态WEB程序中，客户端使用WEB浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给WEB服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过WEB服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。 静态WEB中存在以下几个缺点： 1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。 为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。 实现静态WEB客户端动态效果的手段： JavaScript VBScript 在实际的开发中JavaScript使用得最多。 2、静态WEB无法连接数据库，无法实现和用户的交互。 使用数据库保存数据是现在大多数系统的选择，因为数据库中可以方便地管理数据，增删改查操作可以使用标准的SQL语句完成。 1.5、动态WEB 所谓的动态不是指页面会动，主要的特性的是：“WEB的页面展示效果因时因人而变”，而且动态WEB具有交互性，WEB的页面的内容可以动态更新。整个动态WEB操作的过程图如下： 动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(.htm或者是.htm)还是动态资源。 如果WEB Server Plugin发现客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 如果WEB Server Plugin发现客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。 1.6、动态WEB应用的实现手段 动态WEB现在的实现手段非常多，较为常见的有以下几种： Microsoft ASP、ASP.NET PHP JAVA Servlet/JSP 1、Microsoft ASP、ASP.NET 微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。 ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。 2.PHP PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。 3.Servlet/JSP 这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。 Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。 SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。 二、WEB服务器2.1、WEB服务器简介 1、Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍 1、WebLogic WebLogic是美国bea公司出品的一个application server。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求，启动界面如图 2、WebSphere WebSphere Application Server 是一种功能完善、开放的Web应用程序服务器，是IBM公司电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序。这一整套产品进行了扩展，以适应 Web应用程序服务器的需要，范围从简单到高级直到企业级。启动界面如图： 3、Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4、IIS Microsoft的Web服务器产品为Internet Information Services （IIS），IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。ⅡS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在ⅡS的平 台上。IIS提供了一个图形界面的管理工具，称为Internet信息服务管理器，可用于监视配置和控制Internet服务。 IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三、搭建JavaWeb应用开发环境——Tomcat服务器3.1、疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个web页面，用户是无法访问到的，但是如果启动tomcat服务器，把web页面放在tomcat服务器中，用户就可以访问了。这说明什么问题？ 1、不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。 2、WEB服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器 Tomcat官方站点：http://jakarta.apache.org 下载Tomcat安装程序包：http://tomcat.apache.org/ 点击【Download】跳转到如下图所示的下载页面 tar.gz文件是Linux操作系统下的安装版本 exe文件是Windows系统下的安装版本 zip文件是Windows系统下的压缩版本 下载完成后，得到的是一个压缩包，将压缩包解压就可以完成Tomcat服务器的安装 将压缩包解压后，得到的就是如下图所示的文件夹，这样就完成了Tomcat服务器的安装。 3.3、启动和测试Tomcat服务器 启动Tomcat服务器 双击 bin 目录下的 startup.bat 文件启动Tomcat服务器 测试Tomcat服务器 打开浏览器，输入http://localhost:8080/，能显示如下界面代表安装成功。 3.4、Tomcat启动常见问题 导致Tomcat服务器无法正常启动的原因一般来说就是如下的两个： 1、JAVA_HOME环境变量设置问题 要想双击bin目录下的startup.bat文件启动Tomcat服务器，首先要做的就是在windows中设置JAVA_HOME环境变量，因为Tomcat服务器的启动需要用到这个JAVA_HOME环境变量，如果windows中不存在JAVA_HOME环境变量，则Tomcat服务器是无法启动的。 在Window中配置JAVA_HOME变量 操作步骤(win7系统)：计算机→右键“属性”→高级系统设置→高级→环境变量，如下图所示： 点击系统变量下面的“【新建】”，弹出一个新建系统变量对话框，首先在变量名写上JAVA_HOME，顾名思义，JAVA_HOME的含义就是JDK的安装路径，，然后在变量值写JDK的安装路径，如这里设置的变量值是”D:\Program Files (x86)\Java\jdk1.7.0“，设置好变量值之后，点击【确定】按钮，JAVA_HOME环境变量就设置完成，如下图所示：系统变量中多了一个”JAVA_HOME”变量。 正常来说，学习Java开发的第一步就是配置Path环境变量，比较好的配置方式是先配置JAVA_HOME环境变量，然后在Path变量中使用”%JAVA_HOME%“引用JAVA_HOME变量的值。 所以这个JAVA_HOME环境变量在Window中一般都是已经配置好了的，如果忘记配置JAVA_HOME环境变量，那么可以使用上述的方式配置 2、端口占用问题 因为Tomcat服务器启动时是需要默认是使用8080端口的，如果这个8080端口被别的应用程序占用了，那么Tomcat服务器就无法正常启动，看到的现象就是”Tomcat服务器启动界面会打印出异常错误信息，然后就自动关闭了”，如下图所示： 由于这个窗口从启动到关闭的时间非常短，我们很难通过这个窗口看到Tomcat启动时的报错异常信息，因此我们一般只能通过Tomcat服务器的记录的log(日志)信息去查看Tomcat服务器的运行情况。 在Tomcat服务器的根目录下有一个logs文件夹， logs文件夹存放Tomcat 的日志文件，打开logs文件夹，可以看到里面的log文件，其中有一个以”catalina.yyyy-MM-dd.log“形式命名的log文件，例如”catalina.2014-05-17.log”日志文件就是记录Tomcat服务器2014-05-17这一天的运行情况。 打开catalina.2014-05-17.log文件，看看里面的日志记录信息， 日志信息里面清楚的记录了Tomcat服务器的运行情况，如果因为8080端口被占用而无法正常启动，就会记录如上图所示的异常信息，通过查看异常信息，我们就可知道Tomcat服务器为什么不能够正常启动了！ 总结：当Tomcat服务器无法正常启动时，首先检查是否配置了JAVA_HOME环境变量，然后再检查Tomcat服务器启动时的端口是否被别的应用程序占用了。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP获取绝对路径]]></title>
    <url>%2F2017%2F06%2F27%2FJSP%E8%8E%B7%E5%8F%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[在JavaWeb开发中，常使用绝对路径的方式来引入JavaScript和CSS文件，这样可以避免因为目录变动导致引入文件找不到的情况，常用的做法如下： 一、使用${pageContext.request.contextPath} 代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的。 例如： 123456&lt;!--使用绝对路径的方式引入CSS文件--&gt;&lt;link rel="stylesheet" href="$&#123;pageContext.request.contextPath&#125;/themes/default/css/ueditor.css" type="text/css"/&gt;&lt;!--使用绝对路径的方式引入JavaScript脚本--&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/ueditor1_3_6-gbk-jsp/ueditor.config.js"&gt;&lt;/script&gt; 使用&lt;%=request.getContextPath()%&gt;和使用${pageContext.request.contextPath}达到同样的效果 12&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/ueditor1_3_6-gbk-jsp/ueditor.all.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC将根目录文件夹的权限赋给用户]]></title>
    <url>%2F2017%2F06%2F26%2FMAC%E5%B0%86%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%9D%83%E9%99%90%E8%B5%8B%E7%BB%99%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 1、sudu -i进入root模式（需输入密码）2、chown -R 用户名 /文件夹名1234sudo -iPassword:shuaigedeMacBook-Pro:~ root# mkdir /interestingchown -R shuaige /interesting]]></content>
      <categories>
        <category>Util</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http常见的请求头和响应头]]></title>
    <url>%2F2017%2F06%2F26%2Fhttp%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 1.常见的HTTP请求头部 请求头部 说明 Accept-Charset 用于指定客户端接受的字符集 Accept-Encoding 用于指定可接受的内容编码，如Accept-Encoding:gzip,deflate Accept-Language 用于指定一种自然语言，如Accept-Language:zh-cn User-Agent 客户端将它的操作系统、浏览器和其他属性告诉服务器 Host 用于指定被请求资源的Internet主机和端口号,如Host:www.taobao.com Connection 当前连接是否保持，如Connection:Keep-Alive 2.常见的HTTP响应头 响应头部 说明 Server 使用的服务器名称，如Server:Apache/1.3.6(Unix) Content-Type 用来指明发送给接收者的实体正文的媒体类型，如Content-Type:text/html;charset=GBK Content-Encoding 与请求报头Accept-Encoding对应，告诉浏览器服务端采用什么压缩编码 Content-Langeage 描述资源所使用的自然语言 Content-Length 指明实体正文的长度，用以字节方式存储的十进制数字表示 Keep-Alive 保持连接的时间，如Keep-Alive:timeout=5,max=120 3.常见的HTTP状态码 状态码 说明 200 客户端请求成功 302 临时跳转，跳转地址使用Location指定 400 客户端请求有语法错误，不能被服务器识别 403 服务器接受到请求，但是拒绝提供服务 404 请求资源不存在 500 服务器发生不可预期的错误]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>java-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dbUnit使用]]></title>
    <url>%2F2017%2F06%2F08%2FdbUnit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] ​ DbUnit(http://dbunit.sourceforge.net/ )是专门针对数据库测试框架Junit的一个扩展。本文介绍了使用DbUnit工具让我们在使用Junit测试的时候，不会对数据库造成破坏。本文将会简单的介绍使用dbUnit进行备份和恢复数据操作。 使用DbUnit的步骤:(Maven方式) 1.添加maven依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 2.使用DbUnit进行插入测试数据a.创建测试数据(提供数据配置文件dataset.xml,其中t_user为表名，属性为列名)123&lt;dataset&gt; &lt;t_user id="1" username="admin" password="123" nickname="admin_123"/&gt;&lt;/dataset&gt; b.创建DbUnit的连接信息(这个连接获取需要依赖项目的连接)1234567891011121314151617181920212223242526272829303132333435363738394041public class DbUtil &#123; private static final String url = "jdbc:mysql://127.0.0.1:3306/db_junit?useUnicode=true" + "&amp;characterEncoding=UTF-8"; private static final String username = "root"; private static final String password = "root"; public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url, username, password); return conn; &#125; public static void close(Connection conn) &#123; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(PreparedStatement ps) &#123; try &#123; if (ps != null) ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(ResultSet rs) &#123; try &#123; if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestDbUnit &#123; @Test public void testDbUnit() throws SQLException, DatabaseUnitException &#123; //1.创建dbunit的connection IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取配置的数据 IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource(TestDbUnit.class .getResourceAsStream("/dataset.xml")))); //3.清空数据库,将测试数据添加进去 DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125; //备份所有的数据 @Test public void testBackUpAllData() throws SQLException, DatabaseUnitException, IOException &#123; //1.获取dbunit的连接 IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //2.获取数据库中的所有的数据 IDataSet ds = conn.createDataSet(); //3.将dataset数据写入到一个文件中 FlatXmlDataSet.write(ds,new FileWriter("backUp.xml")); &#125; //备份部分表 @Test public void testBackUpSomeTable() throws SQLException, DatabaseUnitException, IOException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); //创建查询的dataset QueryDataSet queryDataSet = new QueryDataSet(conn); queryDataSet.addTable("t_user"); FlatXmlDataSet.write(queryDataSet,new FileWriter("backUp.xml")); &#125; //测试恢复 @Test public void testResume() throws SQLException, DatabaseUnitException &#123; IDatabaseConnection conn = new DatabaseConnection(DbUtil.getConnection()); IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource("backUp.xml"))); DatabaseOperation.CLEAN_INSERT.execute(conn,ds); &#125;&#125; ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>dbUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown简介]]></title>
    <url>%2F2017%2F01%2F17%2FMarkdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[TOC] Markdown简介 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成各式丰富的HTML页面。–维基百科 图片1![描述](example.jpg) 笔记本1@(笔记本)［标签1，标签2，标签3］ 标题123标题一 标题二======= ----------## 标题二 ###### 标题六 列表121.有序列表 -无序列表 -[] 复选框2.有序列表 -无序列表 -[x] 复选框 引用12&gt; 这是引用的文字&gt; 引用内可以嵌套标题、列表等 代码1234这是一句行内代码｀var a = 1｀,以下是代码区块：&apos;&apos;&apos;rubyprint &apos;Hello world&apos;&apos;&apos;&apos; laTex公式12这是一句行内公式 $ y = x + 1 $,以下为整行公式：$$ a^2 + b^2 = c^2 $$ 表格123|Item | Value| Qty||:-------|--------:|:---:||Computer|1600 USD| 5|]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>